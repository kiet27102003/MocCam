<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M·ªôc C·∫ßm - L√Ω C√¢y B√¥ng</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #7e22ce 50%, #1e293b 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .header p {
            color: #d1d5db;
            font-size: 1.1em;
        }

        .controls {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            color: white;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 150px;
        }

        .control-group select {
            flex: 1;
            min-width: 200px;
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 1em;
            cursor: pointer;
            outline: none;
            transition: all 0.3s;
        }

        .control-group select:hover {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .control-group select:focus {
            border-color: #a78bfa;
            background: rgba(0, 0, 0, 0.5);
        }

        .control-group select option {
            background: #1e293b;
            color: white;
        }

        .control-group button {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            background: #8b5cf6;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
        }

        .control-group button:hover {
            background: #7c3aed;
            transform: translateY(-2px);
        }

        .control-group button:active {
            transform: translateY(0);
        }

        .control-group button:disabled {
            background: #6b7280;
            cursor: not-allowed;
            transform: none;
        }

        .control-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .status-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .status-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 20px;
            color: white;
        }

        .status-card .label {
            font-weight: bold;
            margin-right: 10px;
        }

        .status-card .value {
            font-size: 1.5em;
            font-weight: bold;
        }

        .status-detecting { color: #4ade80; }
        .status-loading { color: #fbbf24; }
        .hand-count { color: #4ade80; }
        .fps-count { color: #a78bfa; }

        .text-gradient-fire {
            background: -webkit-linear-gradient(45deg, #ffd700, #ff4500, #ff8c00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .camera-container {
            position: relative;
            background: black;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            margin-bottom: 30px;
        }

        #videoElement {
            display: none;
        }

        #canvasElement {
            width: 100%;
            height: auto;
            display: block;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: white;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #ef4444;
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            max-width: 80%;
            display: none;
        }

        .error-overlay.show {
            display: block;
        }

        .instructions {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 25px;
            color: white;
            margin-bottom: 20px;
        }

        .instructions h3 {
            font-size: 1.5em;
            margin-bottom: 15px;
        }

        .instructions ul {
            list-style: none;
            padding: 0;
        }

        .instructions li {
            padding: 8px 0;
            color: #d1d5db;
        }

        .footer {
            text-align: center;
            color: #9ca3af;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <span>üéµ</span>
                ƒê√†n Tranh ·∫¢o - M·ªôc C·∫ßm
            </h1>
            <p>S·ª≠ d·ª•ng MediaPipe Hands ƒë·ªÉ ch∆°i ƒë√†n tranh ·∫£o</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>
                    üìπ Ch·ªçn Camera:
                </label>
                <select id="cameraSelect">
                    <option value="">ƒêang t·∫£i danh s√°ch camera...</option>
                </select>
                <button id="switchCameraBtn" disabled>ƒê·ªïi Camera</button>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="showDanTranhToggle" checked>
                    Hi·ªÉn th·ªã ƒê√†n Tranh
                </label>
                <label>
                    <input type="checkbox" id="showHandsToggle" checked>
                    Hi·ªÉn th·ªã Tracking Tay
                </label>
            </div>
            <div class="control-group">
                <label>üé∂ B√†i h√°t:</label>
                <p class="text-gradient-fire" style="font-size: 1.3em; font-weight: bold; flex: 1;">L√Ω C√¢y B√¥ng</p>
                <button id="startSongBtn">‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu</button>
                <button id="stopSongBtn" disabled>‚èπ D·ª´ng</button>
            </div>
            <div id="speedControl" style="margin-top: 10px;">
                <label for="speedSelect">T·ªëc ƒë·ªô: </label>
                <select id="speedSelect">
                    <option value="0.75">0.75x</option>
                    <option value="1.0" selected>1.0x</option>
                    <option value="1.25">1.25x</option>
                    <option value="1.5">1.5x</option>
                    <option value="2.0">2.0x</option>
                </select>
            </div>

        </div>

        <div class="status-bar">
            <div class="status-card">
                <span class="label">üìπ Tr·∫°ng th√°i:</span>
                <span id="statusText" class="value status-loading">ƒêang t·∫£i...</span>
            </div>
            <div class="status-card">
                <span class="label">üëã S·ªë b√†n tay:</span>
                <span id="handCount" class="value hand-count">0</span>
            </div>
            <div class="status-card">
                <span class="label">‚ö° FPS:</span>
                <span id="fpsCount" class="value fps-count">0</span>
            </div>
        </div>

        <div class="camera-container">
            <video id="videoElement" playsinline></video>
            <canvas id="canvasElement"></canvas>
            
            <div id="loadingOverlay" class="loading-overlay">
                <div class="spinner"></div>
                <p style="font-size: 1.2em;">ƒêang kh·ªüi ƒë·ªông camera v√† MediaPipe...</p>
            </div>
            
            <div id="errorOverlay" class="error-overlay">
                <p style="font-weight: bold; margin-bottom: 10px;">L·ªói:</p>
                <p id="errorMessage"></p>
            </div>
        </div>

        <div class="instructions">
            <h3>üìã H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng</h3>
            <ul>
                <li>‚Ä¢ Ch·ªçn camera t·ª´ dropdown ph√≠a tr√™n</li>
                <li>‚Ä¢ ƒê∆∞a b√†n tay v√†o tr∆∞·ªõc camera, ƒë·∫∑t tay ph√≠a tr√™n c√°c d√¢y ƒë√†n</li>
                <li>‚Ä¢ ƒê√†n tranh c√≥ 17 d√¢y ƒë∆∞·ª£c hi·ªÉn th·ªã tr√™n m√†n h√¨nh</li>
                <li>‚Ä¢ S·ª≠ d·ª•ng 3 ng√≥n: **C√°i, Tr·ªè, Gi·ªØa** ƒë·ªÉ g·∫£y</li>
                <li>‚Ä¢ D√¢y ƒë√†n s·∫Ω s√°ng l√™n khi b·∫°n g·∫£y tr√∫ng</li>
            </ul>
        </div>

        <div class="status-card" id="hudScore" style="text-align:center; margin-bottom:20px; color:white;">
            <p>‚≠ê <b>ƒêi·ªÉm:</b> <span id="scoreText">0</span></p>
            <p>üî• <b>Combo:</b> <span id="comboText">0</span></p>
        </div>

        <div class="footer">
            <p>C√¥ng ngh·ªá: MediaPipe Hands | ƒê√†n Tranh 17 d√¢y | Real-time Hand Tracking</p>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('videoElement');
        const canvasElement = document.getElementById('canvasElement');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const errorOverlay = document.getElementById('errorOverlay');
        const errorMessage = document.getElementById('errorMessage');
        const statusText = document.getElementById('statusText');
        const handCountEl = document.getElementById('handCount');
        const fpsCountEl = document.getElementById('fpsCount');
        const cameraSelect = document.getElementById('cameraSelect');
        const switchCameraBtn = document.getElementById('switchCameraBtn');

        const showDanTranhToggle = document.getElementById('showDanTranhToggle');
        const showHandsToggle = document.getElementById('showHandsToggle');
        let showDanTranh = true;
        let showHands = true;

        let frameCount = 0;
        let lastTime = Date.now();
        let currentFps = 0;
        let currentStream = null;
        let currentCamera = null;
        let hands = null;
        let cameraInstance = null;
        let availableCameras = [];
        let isSwitching = false;

        // === M·ªöI: Canvas ƒë·ªám ===
        const staticCanvas = document.createElement('canvas');
        const staticCtx = staticCanvas.getContext('2d');

        // === M·ªöI: BI·∫æN CHO AUDIO ===
        let audioContext;
        let audioBuffers = []; // M·∫£ng ƒë·ªÉ l∆∞u √¢m thanh ƒë√£ gi·∫£i m√£
        // === H·∫æT PH·∫¶N M·ªöI ===

        // === M·ªöI: Bi·∫øn State cho logic g·∫£y d√¢y ===
        let danTranhStrings = []; // M·∫£ng l∆∞u t·ªça ƒë·ªô {id, y, startX, endX} c·ªßa 17 d√¢y
        let stringStates = new Array(17).fill(0); // Tr·∫°ng th√°i "rung" c·ªßa 17 d√¢y (0 = tƒ©nh)
        const FINGER_TIP_LANDMARKS = [4, 8, 12]; // Ch·ªâ s·ªë landmark c·ªßa 3 ƒë·∫ßu ng√≥n: C√°i, Tr·ªè, Gi·ªØa
        // === H·∫æT PH·∫¶N M·ªöI ===

        // === TH√äM BI·∫æN N√ÄY V√ÄO ===
        let previousTouching = new Array(17).fill(false); // L∆∞u tr·∫°ng th√°i ch·∫°m c·ªßa frame TR∆Ø·ªöC
        // === H·∫æT PH·∫¶N TH√äM ===

        // === TH√äM BI·∫æN N√ÄY V√ÄO ===
        let previousHandLandmarks = []; // L∆∞u landmarks c·ªßa frame TR∆Ø·ªöC
        // === H·∫æT PH·∫¶N TH√äM ===
        // === M·ªöI: BI·∫æN RHYTHM GAME ===
        let currentSong = null;
        let isPlayingSong = false;
        let songSpeed = 1.0;
        let isGameOver = false;
        let songStartTime = 0;
        let fallingNotes = []; // c√°c n·ªët ƒëang r∆°i
        let score = 0;
        let combo = 0;
        let maxCombo = 0;
        let accuracyList = [];

        // === PH·∫¶N TH√äM B√ÄI NH·∫†C ===
        const SONGS = {
        // L√Ω C√¢y B√¥ng
        "lycaybong": {
            name: "L√Ω C√¢y B√¥ng",
            speed: 60,
            view: "focused",
            focusStartIndex: 10,
            focusStringCount: 5,
            notes: [
            // Ghi ch√∫: C√°c gi√° tr·ªã 'string' l√† CH·ªà S·ªê G·ªêC (0-16).
            // Logic √°nh x·∫° trong startSong s·∫Ω t·ª± ƒë·ªông chuy·ªÉn ƒë·ªïi ch√∫ng.
            // 1 n·ªët ƒëen = 1000ms, 1 n·ªët m√≥c ƒë∆°n = 500ms.
            
            // --- L·∫ßn l·∫∑p 1 (√î nh·ªãp 2-8) ---
            { time: 1000, string: 10, comment: "Sol3" }, { time: 1500, string: 11, comment: "La3" },
            { time: 2000, string: 10, comment: "Sol3" },
            { time: 3000, string: 10, comment: "Sol3" }, { time: 3500, string: 11, comment: "La3" }, { time: 4000, string: 11, comment: "La3" },
            { time: 4500, string: 10, comment: "Sol3" }, { time: 5000, string: 11, comment: "La3" },
            { time: 6000, string: 10, comment: "Sol3" },
            { time: 7000, string: 11, comment: "La3" },
            { time: 8000, string: 10, comment: "Sol3" }, { time: 8500, string: 12, comment: "Do4" },
            { time: 9000, string: 10, comment: "Sol3" },
            { time: 9500, string: 11, comment: "La3" }, { time: 10000, string: 11, comment: "La3" }, { time: 10500, string: 10, comment: "Sol3" },
            { time: 11000, string: 11, comment: "La3" }, { time: 11500, string: 11, comment: "La3" },
            { time: 12000, string: 10, comment: "Sol3" },
            { time: 13500, string: 12, comment: "Do4" },
            
            // --- L·∫ßn l·∫∑p 2 (√î nh·ªãp 9-16) ---
            { time: 14000, string: 11, comment: "La3" },
            { time: 15000, string: 10, comment: "Sol3" }, { time: 15500, string: 10, comment: "Sol3" }, { time: 16000, string: 10, comment: "Sol3" },
            { time: 17000, string: 11, comment: "La3" },
            { time: 18000, string: 10, comment: "Sol3" }, { time: 18500, string: 12, comment: "Do4" },
            { time: 19000, string: 11, comment: "La3" }, { time: 19500, string: 11, comment: "La3" }, { time: 20000, string: 10, comment: "Sol3" },
            { time: 20500, string: 11, comment: "La3" },
            { time: 21500, string: 12, comment: "Do4" },
            { time: 22000, string: 11, comment: "La3" },
            { time: 23000, string: 11, comment: "La3" }, { time: 23500, string: 10, comment: "Sol3" }, { time: 24000, string: 11, comment: "La3" },
            { time: 24500, string: 10, comment: "Sol3" },
            { time: 25000, string: 11, comment: "La3" },
            { time: 26000, string: 10, comment: "Sol3" }, { time: 26500, string: 12, comment: "Do4" },
            { time: 27000, string: 11, comment: "La3" }, { time: 27500, string: 11, comment: "La3" }, { time: 28000, string: 10, comment: "Sol3" },
            { time: 28500, string: 11, comment: "La3" },
            { time: 29500, string: 12, comment: "Do4" },

            // --- L·∫ßn l·∫∑p 3 (√î nh·ªãp 17-24) ---
            { time: 30000, string: 10, comment: "Sol3" }, { time: 30500, string: 11, comment: "La3" },
            { time: 31000, string: 10, comment: "Sol3" },
            { time: 32000, string: 10, comment: "Sol3" }, { time: 32500, string: 11, comment: "La3" }, { time: 33000, string: 11, comment: "La3" },
            { time: 33500, string: 10, comment: "Sol3" }, { time: 34000, string: 11, comment: "La3" },
            { time: 35000, string: 10, comment: "Sol3" },
            { time: 36000, string: 11, comment: "La3" },
            { time: 37000, string: 10, comment: "Sol3" }, { time: 37500, string: 12, comment: "Do4" },
            { time: 38000, string: 10, comment: "Sol3" },
            { time: 38500, string: 11, comment: "La3" }, { time: 39000, string: 11, comment: "La3" }, { time: 39500, string: 10, comment: "Sol3" },
            { time: 40000, string: 11, comment: "La3" }, { time: 40500, string: 11, comment: "La3" },
            { time: 41000, string: 10, comment: "Sol3" },
            { time: 42500, string: 12, comment: "Do4" },

            // --- L·∫ßn l·∫∑p 4 (√î nh·ªãp 25-32), k·∫øt th√∫c ---
            { time: 43000, string: 11, comment: "La3" },
            { time: 44000, string: 10, comment: "Sol3" }, { time: 44500, string: 10, comment: "Sol3" }, { time: 45000, string: 10, comment: "Sol3" },
            { time: 46000, string: 11, comment: "La3" },
            { time: 47000, string: 10, comment: "Sol3" }, { time: 47500, string: 12, comment: "Do4" },
            { time: 48000, string: 11, comment: "La3" }, { time: 48500, string: 11, comment: "La3" }, { time: 49000, string: 10, comment: "Sol3" },
            { time: 49500, string: 11, comment: "La3" },
            { time: 50500, string: 12, comment: "Do4" },
            { time: 51000, string: 11, comment: "La3" }
            ]
        }
        };

        // === THAY TH·∫æ CONFIG C≈® B·∫∞NG CONFIG N√ÄY ===
        const DAN_TRANH_CONFIG = {
            numStrings: 17, // ƒê√£ l√† 17
            startX: 0.05, 
            endX: 0.95,   
            topY: 0.1,    
            bottomY: 0.9, 
            bridgeWidth: 40, 
            stringColors: [
                '#FFD700', '#FFC700', '#FFB700', '#FFA700', // V√†ng (tr·∫ßm) - 4
                '#FF9700', '#FF8700', '#FF7700', '#FF6700', // Cam (trung) - 8
                '#FF5700', '#FF4700', '#FF3700', '#FF2700', // Cam-ƒë·ªè - 12
                '#FF1700', '#FF0700', '#F70000', '#E70000', // ƒê·ªè (b·ªïng) - 16
                '#D70000'                                   // M√ÄU TH·ª® 17 (Th√™m v√†o) 
            ],
            backgroundColor: '#8B4513',

            // === M·ªöI: Th√™m c·∫•u h√¨nh Rhythm Game ===
            rhythmGame: {
                hitZoneXPercent: 0.74, // V·∫°ch g·∫£y ·ªü 25% t·ª´ tr√°i sang
                noteRadius: 10,       // B√°n k√≠nh n·ªët nh·∫°c (h√¨nh tr√≤n)
                hitZoneColor: 'rgba(0, 255, 255, 0.7)', // M√†u V·∫°ch G·∫£y (Cyan trong su·ªët)
                noteColor: 'rgba(255, 255, 255, 0.9)'  // M√†u N·ªët ƒê√≠ch (Tr·∫Øng g·∫ßn ƒë·ª•c)
            }
            // === H·∫æT PH·∫¶N M·ªöI ===
        };
        // === H·∫æT PH·∫¶N THAY TH·∫æ ===

        // ==== Variables for improved interaction ====
        let lastPluckTime = new Array(DAN_TRANH_CONFIG.numStrings).fill(0);
        const PLUCK_COOLDOWN_MS = 150;
        let prevHands = [];
        let lastFrameTime = performance.now();

        // === M·ªöI: DANH S√ÅCH FILE √ÇM THANH ===
        // B·∫°n B·∫ÆT BU·ªòC ph·∫£i ƒëi·ªÅn ƒë√∫ng 17 ƒë∆∞·ªùng d·∫´n file .wav c·ªßa m√¨nh v√†o ƒë√¢y
        const NOTE_FILES = [
            'sounds/1_G.wav',  // D√¢y 1: G (tr·∫ßm)
            'sounds/1_A.wav',  // D√¢y 2: A
            'sounds/1_C.wav',  // D√¢y 3: C
            'sounds/1_D.wav',  // D√¢y 4: D
            'sounds/1_E.wav',  // D√¢y 5: E
            'sounds/2_G.wav',  // D√¢y 6: G
            'sounds/2_A.wav',  // D√¢y 7: A
            'sounds/2_C.wav',  // D√¢y 8: C
            'sounds/2_D.wav',  // D√¢y 9: D
            'sounds/2_E.wav',  // D√¢y 10: E
            'sounds/3_G.wav',  // D√¢y 11: G
            'sounds/3_A.wav',  // D√¢y 12: A
            'sounds/3_C.wav',  // D√¢y 13: C
            'sounds/3_D.wav',  // D√¢y 14: D
            'sounds/3_E.wav',  // D√¢y 15: E
            'sounds/4_G.wav',  // D√¢y 16: G
            'sounds/4_A.wav'   // D√¢y 17: A (cao nh·∫•t)
        ];
        // === H·∫æT PH·∫¶N M·ªöI ===

        // === ƒê√É S·ª¨A: Ch·ªâ 3 ng√≥n tay ===
        const DAN_TRANH_HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4], // Ng√≥n c√°i (Thumb)
            [0, 5], [5, 6], [6, 7], [7, 8], // Ng√≥n tr·ªè (Index)
            [0, 9], [9, 10], [10, 11], [11, 12], // Ng√≥n gi·ªØa (Middle)
            [5, 9] // N·ªëi l√≤ng b√†n tay (t·ª´ tr·ªè sang gi·ªØa)
        ];

        // === H√ÄM V·∫º ƒê√ÄN TRANH (ƒê√É S·ª¨A) ===
        // H√†m n√†y gi·ªù ƒë·ªçc t·ªça ƒë·ªô t·ª´ `danTranhStrings`
        function drawDanTranh(ctx, width, height) {
            // 1. V·∫Ω n·ªÅn G·ªó (thay cho video)
            if (showDanTranh) {
                ctx.fillStyle = DAN_TRANH_CONFIG.backgroundColor;
                ctx.fillRect(0, 0, width, height);
            } else {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, width, height);
                return; 
            }

            // N·∫øu m·∫£ng t·ªça ƒë·ªô ch∆∞a s·∫µn s√†ng th√¨ kh√¥ng v·∫Ω
            if (danTranhStrings.length === 0) return; 

            // 2. L·∫•y t·ªça ƒë·ªô t·ª´ m·∫£ng (thay v√¨ t√≠nh to√°n l·∫°i)
            const startX = danTranhStrings[0].startX;
            const endX = danTranhStrings[0].endX;
            const topY = danTranhStrings[0].y;
            const bottomY = danTranhStrings[danTranhStrings.length - 1].y;
            const bridgeWidth = DAN_TRANH_CONFIG.bridgeWidth;

            // 3. V·∫Ω khung ƒë√†n (thanh d·ªçc ·ªü 2 b√™n)
            const frameGradientLeft = ctx.createLinearGradient(startX - 20, topY, startX + 10, topY);
            frameGradientLeft.addColorStop(0, 'rgba(101, 67, 33, 0.8)');
            frameGradientLeft.addColorStop(1, 'rgba(139, 90, 43, 0.8)');
            ctx.fillStyle = frameGradientLeft;
            ctx.fillRect(startX - 20, topY - 10, 30, bottomY - topY + 20); // Khung tr√°i

            const frameGradientRight = ctx.createLinearGradient(endX - 10, topY, endX + 20, topY);
            frameGradientRight.addColorStop(0, 'rgba(139, 90, 43, 0.8)');
            frameGradientRight.addColorStop(1, 'rgba(101, 67, 33, 0.8)');
            ctx.fillStyle = frameGradientRight;
            ctx.fillRect(endX - 10, topY - 10, 30, bottomY - topY + 20); // Khung ph·∫£i

            // 4. V·∫Ω d√¢y ƒë√†n (n·∫±m ngang) - L·∫∑p qua m·∫£ng t·ªça ƒë·ªô
            danTranhStrings.forEach((string) => {
                const y = string.y;
                const stringWidth = string.endX - string.startX;
                
                // V·∫Ω con nh·∫°n (c·∫ßu di ƒë·ªông)
                const bridgeX = string.startX + (stringWidth * 0.7); 
                const bridgeGradient = ctx.createLinearGradient(bridgeX, y - 8, bridgeX, y + 8);
                bridgeGradient.addColorStop(0, 'rgba(160, 82, 45, 0.6)');
                bridgeGradient.addColorStop(0.5, 'rgba(205, 133, 63, 0.8)');
                bridgeGradient.addColorStop(1, 'rgba(160, 82, 45, 0.6)');
                ctx.fillStyle = bridgeGradient;
                ctx.beginPath();
                ctx.moveTo(bridgeX, y);
                ctx.lineTo(bridgeX + bridgeWidth, y - 8);
                ctx.lineTo(bridgeX + bridgeWidth, y + 8);
                ctx.closePath();
                ctx.fill();

                // V·∫Ω b√≥ng d√¢y ƒë√†n
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(string.startX, y + 2);
                ctx.lineTo(string.endX, y + 2);
                ctx.stroke();

                // 1. L·∫•y ch·ªâ s·ªë m√†u d·ª±a tr√™n ID th·∫≠t c·ªßa d√¢y ƒë√†n (string.id)
                const colorIndex = string.originalId;
                const color = DAN_TRANH_CONFIG.stringColors[colorIndex] || '#FFD700'; // L·∫•y m√†u ƒë√∫ng

                // V·∫Ω d√¢y ƒë√†n ch√≠nh v·ªõi gradient v√† m√†u ƒë√∫ng
                const stringGradient = ctx.createLinearGradient(string.startX, y, string.endX, y);
                stringGradient.addColorStop(0, color);
                stringGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.4)');
                stringGradient.addColorStop(1, color);
                
                ctx.strokeStyle = stringGradient;
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(string.startX, y);
                ctx.lineTo(string.endX, y);
                ctx.stroke();

                // Th√™m vi·ªÅn s√°ng cho d√¢y
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(string.startX, y - 1);
                ctx.lineTo(string.endX, y - 1);
                ctx.stroke();

                // 2. V·∫Ω s·ªë th·ª© t·ª± d√¢y d·ª±a tr√™n ID th·∫≠t c·ªßa d√¢y ƒë√†n
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(string.originalId + 1, string.startX - 30, y + 5); // D√πng string.id + 1
            });
        }
        // === H·∫æT H√ÄM V·∫º ===

        function drawRhythmElements(ctx, width, height) {
            if (danTranhStrings.length === 0) return;
            const config = DAN_TRANH_CONFIG.rhythmGame;
            const hitZoneX = width * config.hitZoneXPercent;

            // V·∫°ch G·∫£y th·∫≥ng ƒë·ª©ng b√™n ph·∫£i
            ctx.strokeStyle = config.hitZoneColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(hitZoneX, danTranhStrings[0].y - 20);
            ctx.lineTo(hitZoneX, danTranhStrings[danTranhStrings.length - 1].y + 20);
            ctx.stroke();

            // V·∫Ω n·ªët ƒë√≠ch tƒ©nh ·ªü ƒë·∫ßu d√¢y (b√™n ph·∫£i)
            danTranhStrings.forEach(string => {
                ctx.beginPath();
                ctx.arc(hitZoneX, string.y, config.noteRadius, 0, 2 * Math.PI);
                ctx.fillStyle = config.noteColor;
                ctx.fill();
            });
        }


        async function loadAudioFiles() {
            try {
                // Kh·ªüi t·∫°o AudioContext (s·∫Ω b·ªã suspended ƒë·∫øn khi user click)
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const loadPromises = NOTE_FILES.map(async (filePath) => {
                const response = await fetch(filePath);
                if (!response.ok) throw new Error("Kh√¥ng th·ªÉ t·∫£i " + filePath);
                const buffer = await response.arrayBuffer();
                return await audioContext.decodeAudioData(buffer);
                });
                audioBuffers = await Promise.all(loadPromises);
                console.log("ƒê√£ t·∫£i √¢m thanh th√†nh c√¥ng");
            } catch (err) {
                console.error(err);
                showError("L·ªói t·∫£i √¢m thanh: " + err.message);
            }
        }

        async function ensureAudioContextRunning() {
            if (!audioContext)
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext.state === "suspended") {
                try {
                await audioContext.resume();
                } catch (e) {
                console.warn("Kh√¥ng th·ªÉ resume AudioContext", e);
                }
            }
        }


        async function playNote(stringIndex) {
            const targetString = danTranhStrings[stringIndex];

            if (!targetString) {
                console.error(`Kh√¥ng t√¨m th·∫•y d√¢y ƒë√†n v·ªõi ch·ªâ s·ªë game: ${stringIndex}`);
                return;
            }

            // Lu√¥n l·∫•y ch·ªâ s·ªë √¢m thanh t·ª´ `originalId` c·ªßa ch√≠nh d√¢y ƒë√†n ƒë√≥
            const audioIndex = targetString.originalId;

            if (audioIndex < 0 || audioIndex >= audioBuffers.length) return;
            
            await ensureAudioContextRunning();
            const buffer = audioBuffers[audioIndex];
            if (!buffer) return;
            const src = audioContext.createBufferSource();
            src.buffer = buffer;
            src.connect(audioContext.destination);
            src.start(0);
        }


        function showError(msg) {
            errorMessage.textContent = msg;
            errorOverlay.classList.add('show');
            loadingOverlay.classList.add('hidden');
            statusText.textContent = 'L·ªói';
            statusText.className = 'value status-loading';
        }
        
        // === H√ÄM X·ª¨ L√ù FALLING NOTES & SCORING ===
        // === N·ªêT CH·∫†Y NGANG (T·ª™ TR√ÅI ‚Üí PH·∫¢I) ===
        function drawFallingNotes(ctx, width, height) {
            if (!isPlayingSong) return;
            const elapsed = (performance.now() - songStartTime) * songSpeed;

            // T·ªëc ƒë·ªô ch·∫°y ngang (pixel m·ªói ms)
            const speedX = width * 0.00025;

            fallingNotes.forEach(note => {
                const targetString = danTranhStrings[note.string];
                if (!targetString) return;

                // v·ªã tr√≠ X d·ª±a theo th·ªùi gian
                const t = (elapsed - note.time);
                const x = (width * 0.1) + t * speedX; // b·∫Øt ƒë·∫ßu t·ª´ 10% b√™n tr√°i
                const y = targetString.y;

                // ch·ªâ v·∫Ω khi trong m√†n h√¨nh
                if (x > 0 && x < width) {
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.fill();

                    // Hi·ªáu ·ª©ng √°nh s√°ng
                    const glow = ctx.createRadialGradient(x, y, 0, x, y, 20);
                    glow.addColorStop(0, 'rgba(255,255,255,0.6)');
                    glow.addColorStop(1, 'rgba(255,255,255,0)');
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // lo·∫°i b·ªè n·ªët ƒë√£ ch·∫°y kh·ªèi m√†n
            fallingNotes = fallingNotes.filter(n => (elapsed - n.time) < 7000);
        }


        function drawGameOverScreen(ctx, width, height) {
            // L·ªõp ph·ªß m·ªù
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(0, 0, width, height);

            // VƒÉn b·∫£n
            ctx.fillStyle = '#4ade80'; // M√†u xanh l√° c√¢y
            ctx.textAlign = 'center';
            ctx.font = 'bold 48px Segoe UI';
            ctx.fillText('HO√ÄN TH√ÄNH!', width / 2, height / 2 - 80);

            ctx.fillStyle = 'white';
            ctx.font = '32px Segoe UI';
            ctx.fillText(`ƒêi·ªÉm s·ªë: ${Math.round(score)}`, width / 2, height / 2);
            
            ctx.fillStyle = '#ffb347'; // M√†u cam
            ctx.font = 'bold 32px Segoe UI';
            ctx.fillText(`Combo L·ªõn Nh·∫•t: ${maxCombo}`, width / 2, height / 2 + 50);

            ctx.fillStyle = '#d1d5db'; // M√†u x√°m nh·∫°t
            ctx.font = '24px Segoe UI';
            ctx.fillText('Nh·∫•n n√∫t "Ch∆°i l·∫°i" ƒë·ªÉ quay v·ªÅ.', width / 2, height / 2 + 120);
        }


        // Khi ng∆∞·ªùi ch∆°i g·∫£y d√¢y (ƒë∆∞·ª£c g·ªçi trong onResults)
        function handlePluck(stringIndex) {
            if (!isPlayingSong) return;
            const elapsed = performance.now() - songStartTime;

            const width = canvasElement.width;
            const speedX = width * 0.00025;
            const hitZoneX = width * DAN_TRANH_CONFIG.rhythmGame.hitZoneXPercent;

            let bestNote = null;
            let bestDiff = Infinity;

            for (const note of fallingNotes) {
                if (note.string === stringIndex) {
                const noteX = (width * 0.1) + (elapsed - note.time) * speedX;
                const diff = Math.abs(noteX - hitZoneX);
                if (diff < bestDiff) {
                    bestDiff = diff;
                    bestNote = note;
                }
                }
            }

            if (bestNote && bestDiff < 40) {
                score += Math.max(0, 100 - bestDiff * 2);
                combo++;
                maxCombo = Math.max(maxCombo, combo);
                accuracyList.push(bestDiff);
                fallingNotes = fallingNotes.filter(n => n !== bestNote);
            } else {
                combo = 0;
            }
        }


        function startSong(songId) {
            if (!SONGS[songId]) return;
            
            const songConfig = SONGS[songId];
            currentSong = songConfig;

            isPlayingSong = true; 
            isGameOver = false;
            score = 0; combo = 0; maxCombo = 0;
            accuracyList = [];
            songStartTime = performance.now();
            
            // Chu·∫©n b·ªã options ƒë·ªÉ v·∫Ω l·∫°i ƒë√†n
            let options = { isGameMode: true };
            if (songConfig.view === 'focused') {
                options.numStrings = songConfig.focusStringCount;
                options.startIndex = songConfig.focusStartIndex;

                // === B∆Ø·ªöC √ÅNH X·∫† QUAN TR·ªåNG ===
                // Chuy·ªÉn ƒë·ªïi ID g·ªëc trong n·ªët nh·∫°c th√†nh ID logic c·ªßa game
                fallingNotes = JSON.parse(JSON.stringify(songConfig.notes)).map(note => {
                    note.string = note.string - (options.startIndex || 0);
                    return note;
                });
                // ============================
            } else {
                fallingNotes = JSON.parse(JSON.stringify(songConfig.notes));
            }
            
            initializeAppDanTranh(options);
            
            document.getElementById('startSongBtn').disabled = true;
            const stopBtn = document.getElementById('stopSongBtn');
            stopBtn.disabled = false;
            stopBtn.textContent = '‚èπ D·ª´ng';
        }


        function stopSong() {
            isPlayingSong = false;
            isGameOver = false; 
            currentSong = null;
            fallingNotes = [];

            // --- RESET V·ªÄ 17 D√ÇY ---
            DAN_TRANH_CONFIG.numStrings = 17;
            initializeAppDanTranh();

            document.getElementById('startSongBtn').disabled = false;
            const stopBtn = document.getElementById('stopSongBtn');
            stopBtn.disabled = true;
            stopBtn.textContent = '‚èπ D·ª´ng';
        }


        // === H√ÄM ONRESULTS (ƒê√É S·ª¨A HO√ÄN CH·ªàNH) ===
        function onResults(results) {
            // 1. X√≥a canvas
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // 2. V·∫Ω n·ªÅn ƒë√†n tranh (copy t·ª´ canvas ·∫©n)
            if (showDanTranh) {
                canvasCtx.drawImage(staticCanvas, 0, 0);
            }

            // 3. C·∫≠p nh·∫≠t s·ªë tay
            const handCount = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
            handCountEl.textContent = handCount;

            // 4. V·∫Ω tay (n·∫øu b·∫≠t)
            if (showHands && results.multiHandLandmarks) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handedness = results.multiHandedness[i];

                    drawConnections(canvasCtx, landmarks);
                    drawLandmarks(canvasCtx, landmarks);

                    const wrist = landmarks[0];
                    const x = wrist.x * canvasElement.width;
                    const y = wrist.y * canvasElement.height;

                    canvasCtx.fillStyle = '#00ff00';
                    canvasCtx.font = 'bold 24px Arial';
                }
            }

            // === PATCH 6: LOGIC G·∫¢Y D√ÇY M∆Ø·ª¢T V√Ä CH√çNH X√ÅC H∆†N ===
            const now = performance.now();
            const dt = Math.max(1, now - lastFrameTime);
            lastFrameTime = now;

            const pluckToleranceY = 15;            // v√πng ch·∫°m
            const velocityThreshold = 0.05;        // v·∫≠n t·ªëc t·ªëi thi·ªÉu
            const accelThreshold = 0.02;           // gia t·ªëc t·ªëi thi·ªÉu
            const crossingMinDelta = 3;           // v∆∞·ª£t d√¢y √≠t nh·∫•t 10px
            const currentlyTouching = new Array(danTranhStrings.length).fill(false);

            const currentHands = [];
            if (results.multiHandLandmarks) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const label = results.multiHandedness[i]?.label || ('hand' + i);
                    currentHands.push({ label, landmarks: results.multiHandLandmarks[i] });
                }
            }

            for (const hand of currentHands) {
                const prev = prevHands.find(h => h.label === hand.label);
                for (const idx of FINGER_TIP_LANDMARKS) {
                    const cur = hand.landmarks[idx];
                    const prevTip = prev ? prev.landmarks[idx] : null;
                    if (!cur) continue;

                    const curX = (1 - cur.x) * canvasElement.width;
                    const curY = cur.y * canvasElement.height;
                    const prevY = prevTip ? prevTip.y * canvasElement.height : curY;
                    const velY = (curY - prevY) / dt;

                    // === NEW: T√≠nh gia t·ªëc (acceleration) ===
                    const prevVelY = prevTip ? (prevTip._velY || 0) : 0;
                    const accelY = velY - prevVelY;
                    if (cur) cur._velY = velY; // l∆∞u l·∫°i ƒë·ªÉ frame sau d√πng

                    for (const string of danTranhStrings) {
                        const overX = curX > string.startX && curX < string.endX;
                        const near = Math.abs(curY - string.y) < pluckToleranceY;

                        // === NEW: ki·ªÉm tra crossing th·∫≠t s·ª± c√≥ bi√™n ƒë·ªô ƒë·ªß l·ªõn ===
                        const crossed = (
                            (prevY < string.y && curY - string.y > crossingMinDelta) ||
                            (prevY > string.y && string.y - curY > crossingMinDelta)
                        );

                        if (overX && near) currentlyTouching[string.id] = true;

                        // === NEW: G·∫£y th·∫≠t s·ª± (ƒë·∫ßy ƒë·ªß ƒëi·ªÅu ki·ªán) ===
                        if (
                            overX &&
                            crossed &&
                            Math.abs(velY) > velocityThreshold &&
                            Math.abs(accelY) > accelThreshold &&
                            stringStates[string.id] === 0
                        ) {
                            const nowMs = performance.now();
                            if (nowMs - lastPluckTime[string.id] >= PLUCK_COOLDOWN_MS) {
                                lastPluckTime[string.id] = nowMs;
                                stringStates[string.id] = 10;
                                playNote(string.id);
                                handlePluck(string.id);
                                console.log(`G·∫£y d√¢y ${string.originalId + 1} (ng√≥n ${idx}, vel=${velY.toFixed(3)}, acc=${accelY.toFixed(3)})`);
                                break;
                            }
                        }
                    }
                }
            }

            // C·∫≠p nh·∫≠t prevHands
            prevHands = currentHands.map(h => ({
                label: h.label,
                landmarks: JSON.parse(JSON.stringify(h.landmarks))
            }));



            // 6. HI·ªÜU ·ª®NG RUNG D√ÇY M∆Ø·ª¢T
            for (let i = 0; i < danTranhStrings.length; i++) {
                const string = danTranhStrings[i];
                if (!string) continue;
                if (stringStates[i] > 0) stringStates[i]--;

                const amp = Math.sin(now / 30) * stringStates[i] * 0.4;
                const gradient = canvasCtx.createLinearGradient(string.startX, string.y, string.endX, string.y);
                gradient.addColorStop(0, "#ffb347");
                gradient.addColorStop(1, "#ffd700");
                canvasCtx.strokeStyle = gradient;
                canvasCtx.lineWidth = 2;
                canvasCtx.beginPath();
                const wave = Math.sin(now / 25) * 0.2;
                const midY = string.y + amp * Math.sin((i * 0.5 + now / 120) % Math.PI);
                canvasCtx.moveTo(string.startX, midY - wave);
                canvasCtx.lineTo(string.endX, midY + wave);
                canvasCtx.stroke();
            }

            // 7. T√çNH FPS
            frameCount++;
            const nowTime = Date.now();
            if (nowTime - lastTime >= 1000) {
                currentFps = frameCount;
                fpsCountEl.textContent = currentFps;
                frameCount = 0;
                lastTime = nowTime;
            }

            // 8. L∆∞u l·∫°i tr·∫°ng th√°i frame n√†y
            previousTouching = [...currentlyTouching];
            previousHandLandmarks = results.multiHandLandmarks ? JSON.parse(JSON.stringify(results.multiHandLandmarks)) : [];
            
            // === C·∫¨P NH·∫¨T HUD ===
            document.getElementById("scoreText").textContent = Math.round(score);
            document.getElementById("comboText").textContent = combo;

            // === TH√äM KH·ªêI 1: T·ª∞ ƒê·ªòNG CHUY·ªÇN SANG GAME OVER ===
            if (isPlayingSong && !isGameOver && fallingNotes.length === 0) {
                const lastNoteTime = currentSong.notes[currentSong.notes.length - 1].time;
                const songEndTime = songStartTime + lastNoteTime + 2000; // Th√™m 2 gi√¢y ch·ªù

                if (performance.now() > songEndTime) {
                    console.log("B√†i h√°t ƒë√£ k·∫øt th√∫c, hi·ªÉn th·ªã m√†n h√¨nh k·∫øt qu·∫£.");
                    isPlayingSong = false; // D·ª´ng logic game
                    isGameOver = true;   // Chuy·ªÉn sang m√†n h√¨nh k·∫øt th√∫c

                    // ƒê·ªïi n√∫t "D·ª´ng" th√†nh n√∫t "Ch∆°i l·∫°i"
                    const stopBtn = document.getElementById('stopSongBtn');
                    stopBtn.textContent = "üéµ Ch∆°i l·∫°i";
                    stopBtn.disabled = false; // ƒê·∫£m b·∫£o n√∫t n√†y c√≥ th·ªÉ nh·∫•n ƒë∆∞·ª£c
                }
            }
            // ===============================================

            // V·∫Ω n·ªët r∆°i (n·∫øu ƒëang ch∆°i)
            drawFallingNotes(canvasCtx, canvasElement.width, canvasElement.height);

            // === TH√äM KH·ªêI 2: V·∫º M√ÄN H√åNH GAME OVER ===
            if (isGameOver) {
                drawGameOverScreen(canvasCtx, canvasElement.width, canvasElement.height);
            }
            // ==========================================

        }
        // === H·∫æT H√ÄM ONRESULTS ===


        // === H√ÄM V·∫º ƒê∆Ø·ªúNG N·ªêI CHU·∫®N 5 NG√ìN (THEO MEDIA PIPE) ===
        function drawConnections(ctx, landmarks) {
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
            ctx.lineWidth = 2;

            const fingers = [
                [0, 1, 2, 3, 4],    // Thumb
                [0, 5, 6, 7, 8],    // Index
                [0, 9, 10, 11, 12], // Middle
                [0, 13, 14, 15, 16],// Ring
                [0, 17, 18, 19, 20] // Pinky
            ];

            ctx.beginPath();
            for (const finger of fingers) {
                for (let i = 0; i < finger.length - 1; i++) {
                const a = landmarks[finger[i]];
                const b = landmarks[finger[i + 1]];
                ctx.moveTo(a.x * canvasElement.width, a.y * canvasElement.height);
                ctx.lineTo(b.x * canvasElement.width, b.y * canvasElement.height);
                }
            }
            ctx.stroke();
        }


        // === H√ÄM V·∫º ƒêI·ªÇM (ƒê√É S·ª¨A) ===
        // === PHI√äN B·∫¢N M√ÄU 5 NG√ìN (N·∫æU MU·ªêN PH√ÇN BI·ªÜT) ===
        function drawLandmarks(ctx, landmarks) {
            const fingerColors = ['#ff4444', '#44ff44', '#4444ff', '#ffbb33', '#aa44ff'];
            const fingers = [
                [0, 1, 2, 3, 4], [5, 6, 7, 8],
                [9, 10, 11, 12], [13, 14, 15, 16],
                [17, 18, 19, 20]
            ];

            for (let f = 0; f < fingers.length; f++) {
                ctx.beginPath();
                for (const i of fingers[f]) {
                const lm = landmarks[i];
                const x = lm.x * canvasElement.width;
                const y = lm.y * canvasElement.height;
                ctx.moveTo(x, y);
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                }
                ctx.fillStyle = fingerColors[f];
                ctx.fill();
            }
        }



        // === H·∫æT H√ÄM V·∫º ƒêI·ªÇM ===
        // === H√ÄM KH·ªûI T·∫†O ƒê√ÄN TRANH - PHI√äN B·∫¢N HO√ÄN CH·ªàNH ===
        function initializeAppDanTranh(options = {}) {
            // ƒê·∫£m b·∫£o video ƒë√£ c√≥ k√≠ch th∆∞·ªõc ƒë·ªÉ tr√°nh l·ªói
            if (!videoElement.videoWidth) return;

            const width = videoElement.videoWidth;
            const height = videoElement.videoHeight;
            
            // C·∫≠p nh·∫≠t l·∫°i canvas tƒ©nh (n·ªÅn)
            staticCanvas.width = width;
            staticCanvas.height = height;
            
            // L·∫•y th√¥ng s·ªë t·ª´ `options` ƒë∆∞·ª£c truy·ªÅn v√†o, ho·∫∑c d√πng gi√° tr·ªã m·∫∑c ƒë·ªãnh (17 d√¢y, b·∫Øt ƒë·∫ßu t·ª´ 0)
            const numStrings = options.numStrings || 17;
            const startIndex = options.startIndex || 0;

            danTranhStrings = []; // Lu√¥n x√≥a m·∫£ng c≈© ƒë·ªÉ t·∫°o m·ªõi
            stringStates = new Array(numStrings).fill(0);

            const { startX, endX, topY, bottomY } = DAN_TRANH_CONFIG;
            // ƒê·∫£m b·∫£o kh√¥ng b·ªã chia cho 0 n·∫øu ch·ªâ c√≥ 1 d√¢y
            const spacingDivisor = numStrings > 1 ? numStrings - 1 : 1;
            const stringSpacing = (height * bottomY - height * topY) / spacingDivisor;

            for (let i = 0; i < numStrings; i++) {
                danTranhStrings.push({
                    id: i, // ID logic game, lu√¥n l√† 0, 1, 2...
                    originalId: startIndex + i, // ID g·ªëc, ƒë∆∞·ª£c t√≠nh to√°n t·ª´ startIndex
                    y: height * topY + i * stringSpacing,
                    startX: width * startX,
                    endX: width * endX,
                });
            }

            // V·∫Ω l·∫°i ƒë√†n l√™n canvas tƒ©nh
            staticCtx.clearRect(0, 0, width, height);
            drawDanTranh(staticCtx, width, height);

            // N·∫øu l√† ch·∫ø ƒë·ªô game, v·∫Ω th√™m c√°c v·∫°ch g·∫£y
            if (options.isGameMode) {
                drawRhythmElements(staticCtx, width, height);
            }
        }


        async function getCameraList() {
            try {
                const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
                tempStream.getTracks().forEach(track => track.stop());

                const devices = await navigator.mediaDevices.enumerateDevices();
                availableCameras = devices.filter(device => device.kind === 'videoinput');
                
                cameraSelect.innerHTML = '';
                
                if (availableCameras.length === 0) {
                    cameraSelect.innerHTML = '<option value="">Kh√¥ng t√¨m th·∫•y camera</option>';
                    return;
                }

                availableCameras.forEach((camera, index) => {
                    const option = document.createElement('option');
                    option.value = camera.deviceId;
                    option.textContent = camera.label || `Camera ${index + 1}`;
                    cameraSelect.appendChild(option);
                });

                switchCameraBtn.disabled = false;
            } catch (err) {
                console.error('Error getting camera list:', err);
                cameraSelect.innerHTML = '<option value="">L·ªói khi t·∫£i camera</option>';
                showError('Kh√¥ng th·ªÉ l·∫•y danh s√°ch camera. Vui l√≤ng c·∫•p quy·ªÅn truy c·∫≠p camera v√† t·∫£i l·∫°i trang.');
            }
        }

        async function stopCurrentCamera() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
            if (cameraInstance) {
                cameraInstance.stop();
                cameraInstance = null;
            }
            videoElement.srcObject = null;
        }

        // === H√ÄM STARTCAMERA (ƒê√É T·ªêI ∆ØU - D√ôNG CAMERA C·ª¶A MEDIAPIPE) ===
        async function startCamera(deviceId) {
        if (isSwitching) return;

        try {
            isSwitching = true;
            switchCameraBtn.disabled = true;
            switchCameraBtn.textContent = 'ƒêang ƒë·ªïi...';
            loadingOverlay.classList.remove('hidden');
            errorOverlay.classList.remove('show');

            await stopCurrentCamera();
            await new Promise((resolve) => setTimeout(resolve, 500));

            const constraints = {
            video: {
                width: 1280,
                height: 720,
                deviceId: deviceId ? { exact: deviceId } : undefined,
            },
            };
            currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            videoElement.srcObject = currentStream;

            await new Promise((resolve) => (videoElement.onloadedmetadata = resolve));
            await videoElement.play();

            const width = videoElement.videoWidth;
            const height = videoElement.videoHeight;
            canvasElement.width = width;
            canvasElement.height = height;

            // === G·ªåI H√ÄM KH·ªûI T·∫†O ƒê√ÄN TRANH ===
            initializeAppDanTranh();

            // === D√ôNG CAMERA C·ª¶A MEDIAPIPE (R·∫§T M∆Ø·ª¢T) ===
            cameraInstance = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720,
            });
            cameraInstance.start();

            loadingOverlay.classList.add('hidden');
            statusText.textContent = 'ƒêang ph√°t hi·ªán';
            statusText.className = 'value status-detecting';

            currentCamera = deviceId;
            cameraSelect.value = deviceId;
            switchCameraBtn.disabled = false;
            switchCameraBtn.textContent = 'ƒê·ªïi Camera';
            isSwitching = false;
        } catch (err) {
            isSwitching = false;
            switchCameraBtn.disabled = false;
            switchCameraBtn.textContent = 'ƒê·ªïi Camera';
            showError('Kh√¥ng th·ªÉ truy c·∫≠p camera: ' + err.message);
        }
        }


        async function initializeApp() {
            try {
                hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });

                hands.setOptions({
                    selfieMode: true,
                    maxNumHands: 2,
                    modelComplexity: 0,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults(onResults);

                // === TH√äM D√íNG N√ÄY V√ÄO ===
                await loadAudioFiles(); // T·∫£i √¢m thanh tr∆∞·ªõc khi l√†m m·ªçi th·ª©
                // === H·∫æT PH·∫¶N TH√äM ===

                await getCameraList();
                
                const defaultCamera = availableCameras.length > 0 ? availableCameras[0].deviceId : null;
                if (defaultCamera) {
                    cameraSelect.value = defaultCamera;
                    await startCamera(defaultCamera);
                } else if (availableCameras.length === 0 && !errorOverlay.classList.contains('show')) {
                    showError('Kh√¥ng t√¨m th·∫•y camera n√†o tr√™n thi·∫øt b·ªã');
                }

            } catch (err) {
                showError('L·ªói kh·ªüi t·∫°o: ' + err.message);
            }
        }
        // === G·∫ÆN S·ª∞ KI·ªÜN THAY ƒê·ªîI T·ªêC ƒê·ªò B√ÄI H√ÅT ===
        document.getElementById('speedSelect').addEventListener('change', (e) => {
            songSpeed = parseFloat(e.target.value);
            console.log("T·ªëc ƒë·ªô b√†i h√°t:", songSpeed + "x");
        });

        // === G·∫ÆN S·ª∞ KI·ªÜN CHUY·ªÇN CAMERA ===
        switchCameraBtn.addEventListener('click', async () => {
        const selectedCamera = cameraSelect.value;
        if (selectedCamera && selectedCamera !== currentCamera && !isSwitching) {
            await startCamera(selectedCamera);
        }
        });

        showDanTranhToggle.addEventListener('change', (e) => {
            showDanTranh = e.target.checked;
            
            // Lu√¥n g·ªçi h√†m trung t√¢m ƒë·ªÉ v·∫Ω l·∫°i ƒë√†n m·ªôt c√°ch an to√†n
            // Chu·∫©n b·ªã options d·ª±a tr√™n tr·∫°ng th√°i game hi·ªán t·∫°i
            let options = {};
            if (isPlayingSong || isGameOver) {
                options.isGameMode = true;
                // L·∫•y l·∫°i c·∫•u h√¨nh t·ª´ m·∫£ng danTranhStrings ƒëang c√≥
                options.numStrings = danTranhStrings.length; 
                options.startIndex = danTranhStrings.length > 0 ? danTranhStrings[0].originalId : 0;
            }
            initializeAppDanTranh(options);
        });

        showHandsToggle.addEventListener('change', (e) => {
            showHands = e.target.checked;
        });
        // === G·∫ÆN S·ª∞ KI·ªÜN CH∆†I NH·∫†C ===
        const startSongBtn = document.getElementById('startSongBtn');
        const stopSongBtn = document.getElementById('stopSongBtn');

        startSongBtn.addEventListener('click', () => {
            const songId = "lycaybong"; // G√°n c·ª©ng ID c·ªßa b√†i h√°t
            startSong(songId);
        });

        stopSongBtn.addEventListener('click', () => {
        stopSong();
        });

        window.addEventListener('load', initializeApp);

        window.addEventListener('beforeunload', () => {
            stopCurrentCamera();
        });
    </script>
</body>
</html>