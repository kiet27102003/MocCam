<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M·ªôc C·∫ßm - ƒê√†n Tranh ·∫¢o MediaPipe</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #A80000 50%, #1e293b 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .header p {
            color: #d1d5db;
            font-size: 1.1em;
        }

        .controls {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            color: white;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 150px;
        }

        .control-group select {
            flex: 1;
            min-width: 200px;
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 1em;
            cursor: pointer;
            outline: none;
            transition: all 0.3s;
        }

        .control-group select:hover {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .control-group select:focus {
            border-color: #a78bfa;
            background: rgba(0, 0, 0, 0.5);
        }

        .control-group select option {
            background: #1e293b;
            color: white;
        }

        .control-group button {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            background: #8b5cf6;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
        }

        .control-group button:hover {
            background: #7c3aed;
            transform: translateY(-2px);
        }

        .control-group button:active {
            transform: translateY(0);
        }

        .control-group button:disabled {
            background: #6b7280;
            cursor: not-allowed;
            transform: none;
        }

        .control-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .status-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .status-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 20px;
            color: white;
        }

        .status-card .label {
            font-weight: bold;
            margin-right: 10px;
        }

        .status-card .value {
            font-size: 1.5em;
            font-weight: bold;
        }

        .status-detecting { color: #4ade80; }
        .status-loading { color: #fbbf24; }
        .hand-count { color: #4ade80; }
        .fps-count { color: #a78bfa; }

        .camera-container {
            position: relative;
            background: black;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            margin-bottom: 30px;
        }

        #videoElement {
            display: none;
        }

        #canvasElement {
            width: 100%;
            height: auto;
            display: block;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: white;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #ef4444;
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            max-width: 80%;
            display: none;
        }

        .error-overlay.show {
            display: block;
        }

        .instructions {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 25px;
            color: white;
            margin-bottom: 20px;
        }

        .instructions h3 {
            font-size: 1.5em;
            margin-bottom: 15px;
        }

        .instructions ul {
            list-style: none;
            padding: 0;
        }

        .instructions li {
            padding: 8px 0;
            color: #d1d5db;
        }

        .footer {
            text-align: center;
            color: #9ca3af;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <span>üéµ</span>
                ƒê√†n Tranh ·∫¢o - M·ªôc C·∫ßm
            </h1>
            <p>S·ª≠ d·ª•ng MediaPipe Hands ƒë·ªÉ ch∆°i ƒë√†n tranh ·∫£o</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>
                    üìπ Ch·ªçn Camera:
                </label>
                <select id="cameraSelect">
                    <option value="">ƒêang t·∫£i danh s√°ch camera...</option>
                </select>
                <button id="switchCameraBtn" disabled>ƒê·ªïi Camera</button>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="showDanTranhToggle" checked>
                    Hi·ªÉn th·ªã ƒê√†n Tranh
                </label>
                <label>
                    <input type="checkbox" id="showHandsToggle" checked>
                    Hi·ªÉn th·ªã Tracking Tay
                </label>
            </div>
            <div class="control-group">
                <label>üé∂ Ch·ªçn b√†i h√°t:</label>
                <select id="songSelect">
                    <option value="">-- Ch·ªçn b√†i --</option>
                    <option value="trongcom">Tr·ªëng C∆°m</option>
                </select>
                <button id="startSongBtn">‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu</button>
                <button id="stopSongBtn" disabled>‚èπ D·ª´ng</button>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-card">
                <span class="label">üìπ Tr·∫°ng th√°i:</span>
                <span id="statusText" class="value status-loading">ƒêang t·∫£i...</span>
            </div>
            <div class="status-card">
                <span class="label">üëã S·ªë b√†n tay:</span>
                <span id="handCount" class="value hand-count">0</span>
            </div>
            <div class="status-card">
                <span class="label">‚ö° FPS:</span>
                <span id="fpsCount" class="value fps-count">0</span>
            </div>
        </div>

        <div class="camera-container">
            <video id="videoElement" playsinline></video>
            <canvas id="canvasElement"></canvas>
            
            <div id="loadingOverlay" class="loading-overlay">
                <div class="spinner"></div>
                <p style="font-size: 1.2em;">ƒêang kh·ªüi ƒë·ªông camera v√† MediaPipe...</p>
            </div>
            
            <div id="errorOverlay" class="error-overlay">
                <p style="font-weight: bold; margin-bottom: 10px;">L·ªói:</p>
                <p id="errorMessage"></p>
            </div>
        </div>

        <div class="instructions">
            <h3>üìã H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng</h3>
            <ul>
                <li>‚Ä¢ Ch·ªçn camera t·ª´ dropdown ph√≠a tr√™n</li>
                <li>‚Ä¢ ƒê∆∞a b√†n tay v√†o tr∆∞·ªõc camera, ƒë·∫∑t tay ph√≠a tr√™n c√°c d√¢y ƒë√†n</li>
                <li>‚Ä¢ ƒê√†n tranh c√≥ 16 d√¢y ƒë∆∞·ª£c hi·ªÉn th·ªã tr√™n m√†n h√¨nh</li>
                <li>‚Ä¢ S·ª≠ d·ª•ng 3 ng√≥n: **C√°i, Tr·ªè, Gi·ªØa** ƒë·ªÉ g·∫£y</li>
                <li>‚Ä¢ D√¢y ƒë√†n s·∫Ω s√°ng l√™n khi b·∫°n g·∫£y tr√∫ng</li>
            </ul>
        </div>

        <div class="status-card" id="hudScore" style="text-align:center; margin-bottom:20px; color:white;">
            <p>‚≠ê <b>ƒêi·ªÉm:</b> <span id="scoreText">0</span></p>
            <p>üî• <b>Combo:</b> <span id="comboText">0</span></p>
        </div>

        <div class="footer">
            <p>C√¥ng ngh·ªá: MediaPipe Hands | ƒê√†n Tranh 16 d√¢y | Real-time Hand Tracking</p>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('videoElement');
        const canvasElement = document.getElementById('canvasElement');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const errorOverlay = document.getElementById('errorOverlay');
        const errorMessage = document.getElementById('errorMessage');
        const statusText = document.getElementById('statusText');
        const handCountEl = document.getElementById('handCount');
        const fpsCountEl = document.getElementById('fpsCount');
        const cameraSelect = document.getElementById('cameraSelect');
        const switchCameraBtn = document.getElementById('switchCameraBtn');

        const showDanTranhToggle = document.getElementById('showDanTranhToggle');
        const showHandsToggle = document.getElementById('showHandsToggle');
        let showDanTranh = true;
        let showHands = true;

        let frameCount = 0;
        let lastTime = Date.now();
        let currentFps = 0;
        let currentStream = null;
        let currentCamera = null;
        let hands = null;
        let cameraInstance = null;
        let availableCameras = [];
        let isSwitching = false;

        // === M·ªöI: Canvas ƒë·ªám ===
        const staticCanvas = document.createElement('canvas');
        const staticCtx = staticCanvas.getContext('2d');

        // === M·ªöI: BI·∫æN CHO AUDIO ===
        let audioContext;
        let audioBuffers = []; // M·∫£ng ƒë·ªÉ l∆∞u √¢m thanh ƒë√£ gi·∫£i m√£
        // === H·∫æT PH·∫¶N M·ªöI ===

        // === M·ªöI: Bi·∫øn State cho logic g·∫£y d√¢y ===
        let danTranhStrings = []; // M·∫£ng l∆∞u t·ªça ƒë·ªô {id, y, startX, endX} c·ªßa 16 d√¢y
        let stringStates = new Array(17).fill(0); // Tr·∫°ng th√°i "rung" c·ªßa 16 d√¢y (0 = tƒ©nh)
        const FINGER_TIP_LANDMARKS = [4, 8, 12]; // Ch·ªâ s·ªë landmark c·ªßa 3 ƒë·∫ßu ng√≥n: C√°i, Tr·ªè, Gi·ªØa
        // === H·∫æT PH·∫¶N M·ªöI ===

        // === TH√äM BI·∫æN N√ÄY V√ÄO ===
        let previousTouching = new Array(17).fill(false); // L∆∞u tr·∫°ng th√°i ch·∫°m c·ªßa frame TR∆Ø·ªöC
        // === H·∫æT PH·∫¶N TH√äM ===

        // === TH√äM BI·∫æN N√ÄY V√ÄO ===
        let previousHandLandmarks = []; // L∆∞u landmarks c·ªßa frame TR∆Ø·ªöC
        // === H·∫æT PH·∫¶N TH√äM ===
        // === M·ªöI: BI·∫æN RHYTHM GAME ===
        let currentSong = null;
        let isPlayingSong = false;
        let songStartTime = 0;
        let fallingNotes = []; // c√°c n·ªët ƒëang r∆°i
        let score = 0;
        let combo = 0;
        let maxCombo = 0;
        let accuracyList = [];

        // === M·ªöI: B√ÄI TR·ªêNG C∆†M (5 D√ÇY DEMO) ===
        const SONGS = {
            "trongcom": {
                name: "Tr·ªëng C∆°m",
                speed: 120, // T·ªëc ƒë·ªô (nh·ªãp m·ªói ph√∫t), b·∫°n c√≥ th·ªÉ ch·ªânh th√†nh 100 cho ch·∫≠m h∆°n
                notes: [
                    // --- Intro (Nh·∫°c d·∫°o ng·∫Øn) ---
                    { time: 500,  string: 0 }, // Sol
                    { time: 1000, string: 1 }, // La
                    { time: 1500, string: 2 }, // ƒê√¥
                    { time: 2000, string: 1 }, // La

                    // --- Verse 1 ---
                    // "T√¨nh b·∫±ng c√≥ c√°i tr·ªëng c∆°m," (Sol Sol La La ƒê√¥ ƒê√¥)
                    { time: 3000, string: 0 },
                    { time: 3500, string: 0 },
                    { time: 4000, string: 1 },
                    { time: 4500, string: 1 },
                    { time: 5000, string: 2 },
                    { time: 5500, string: 2 },
                    // "khen ai kh√©o v·ªó" (R√™ Mi R√™ ƒê√¥)
                    { time: 6000, string: 3 },
                    { time: 6500, string: 4 },
                    { time: 7000, string: 3 },
                    { time: 7500, string: 2 },
                    // "·ªõ m·∫•y b√¥ng m√† l√™n b√¥ng," (La Sol La ƒê√¥ La Sol)
                    { time: 8000, string: 1 },
                    { time: 8500, string: 0 },
                    { time: 9000, string: 1 },
                    { time: 9500, string: 2 },
                    { time: 10000, string: 1 },
                    { time: 10500, string: 0 },
                    // "·ªõ m·∫•y b√¥ng m√† l√™n b√¥ng." (La Sol La ƒê√¥ La Sol)
                    { time: 11000, string: 1 },
                    { time: 11500, string: 0 },
                    { time: 12000, string: 1 },
                    { time: 12500, string: 2 },
                    { time: 13000, string: 1 },
                    { time: 13500, string: 0 },

                    // --- Verse 2 ---
                    // "M·ªôt v·∫ßy tang t√¨nh con s√≠t," (Sol Sol La La ƒê√¥ ƒê√¥)
                    { time: 15000, string: 0 },
                    { time: 15500, string: 0 },
                    { time: 16000, string: 1 },
                    { time: 16500, string: 1 },
                    { time: 17000, string: 2 },
                    { time: 17500, string: 2 },
                    // "m·ªôt v·∫ßy tang t√¨nh con s√≠t," (Sol Sol La La ƒê√¥ ƒê√¥)
                    { time: 18000, string: 0 },
                    { time: 18500, string: 0 },
                    { time: 19000, string: 1 },
                    { time: 19500, string: 1 },
                    { time: 20000, string: 2 },
                    { time: 20500, string: 2 },
                    // "·ªõ m·∫•y l·ªôi, l·ªôi, l·ªôi s√¥ng" (R√™ R√™ ƒê√¥ La)
                    { time: 21000, string: 3 },
                    { time: 21500, string: 3 },
                    { time: 22000, string: 2 },
                    { time: 22500, string: 1 },
                    // "·ªõ m·∫•y ƒëi t√¨m em nh·ªõ th∆∞∆°ng ai." (La ƒê√¥ R√™ ƒê√¥ La Sol)
                    { time: 23000, string: 1 },
                    { time: 23500, string: 2 },
                    { time: 24000, string: 3 },
                    { time: 24500, string: 2 },
                    { time: 25000, string: 1 },
                    { time: 25500, string: 0 },

                    // --- Verse 3 ---
                    // "·ªí con m·∫Øt ·ªõ m·∫•y l·ªãm dim," (ƒê√¥ ƒê√¥ R√™ R√™ Mi Mi)
                    { time: 27000, string: 2 },
                    { time: 27500, string: 2 },
                    { time: 28000, string: 3 },
                    { time: 28500, string: 3 },
                    { time: 29000, string: 4 },
                    { time: 29500, string: 4 },
                    // "·ªì con m·∫Øt ·ªõ m·∫•y l·ªãm dim." (ƒê√¥ ƒê√¥ R√™ R√™ Mi Mi)
                    { time: 30000, string: 2 },
                    { time: 30500, string: 2 },
                    { time: 31000, string: 3 },
                    { time: 31500, string: 3 },
                    { time: 32000, string: 4 },
                    { time: 32500, string: 4 },

                    // --- Verse 4 ---
                    // "M·ªôt v·∫ßy tang t√¨nh con nh·ªán," (Sol Sol La La ƒê√¥ ƒê√¥)
                    { time: 34000, string: 0 },
                    { time: 34500, string: 0 },
                    { time: 35000, string: 1 },
                    { time: 35500, string: 1 },
                    { time: 36000, string: 2 },
                    { time: 36500, string: 2 },
                    // "√¥ ·ªë √¥ √¥ m·∫•y giƒÉng t∆°." (Mi R√™ ƒê√¥ La Sol Sol)
                    { time: 37000, string: 4 },
                    { time: 37500, string: 3 },
                    { time: 38000, string: 2 },
                    { time: 38500, string: 1 },
                    { time: 39000, string: 0 },
                    { time: 39500, string: 0 },
                    // "GiƒÉng t∆° ·ªõ m·∫•y t∆° h·ªìng em nh·ªõ th∆∞∆°ng ai." (La ƒê√¥ R√™ ƒê√¥ La Sol)
                    { time: 40000, string: 1 },
                    { time: 40500, string: 2 },
                    { time: 41000, string: 3 },
                    { time: 41500, string: 2 },
                    { time: 42000, string: 1 },
                    { time: 42500, string: 0 },

                    // --- Outro ---
                    // "Duy√™n n·ª£ ch·ªõ m·∫•y tang b·ªìng," (Sol Sol La La ƒê√¥ ƒê√¥)
                    { time: 44000, string: 0 },
                    { time: 44500, string: 0 },
                    { time: 45000, string: 1 },
                    { time: 45500, string: 1 },
                    { time: 46000, string: 2 },
                    { time: 46500, string: 2 },
                    // "duy√™n n·ª£ ch·ªõ m·∫•y tang b·ªìng." (R√™ Mi R√™ ƒê√¥ La Sol - K·∫øt b√†i)
                    { time: 47000, string: 3 },
                    { time: 47500, string: 4 },
                    { time: 48000, string: 3 },
                    { time: 48500, string: 2 },
                    { time: 49000, string: 1 },
                    { time: 49500, string: 0 },
                ]
            }
        };

        // === THAY TH·∫æ CONFIG C≈® B·∫∞NG CONFIG N√ÄY ===
        const DAN_TRANH_CONFIG = {
            numStrings: 17, // ƒê√£ l√† 17
            startX: 0.05, 
            endX: 0.95,   
            topY: 0.1,    
            bottomY: 0.9, 
            bridgeWidth: 40, 
            stringColors: [
                '#FFD700', '#FFC700', '#FFB700', '#FFA700', // V√†ng (tr·∫ßm) - 4
                '#FF9700', '#FF8700', '#FF7700', '#FF6700', // Cam (trung) - 8
                '#FF5700', '#FF4700', '#FF3700', '#FF2700', // Cam-ƒë·ªè - 12
                '#FF1700', '#FF0700', '#F70000', '#E70000', // ƒê·ªè (b·ªïng) - 16
                '#D70000'                                   // M√ÄU TH·ª® 17 (Th√™m v√†o) 
            ],
            backgroundColor: '#8B4513',

            // === M·ªöI: Th√™m c·∫•u h√¨nh Rhythm Game ===
            rhythmGame: {
                hitZoneXPercent: 0.74, // V·∫°ch g·∫£y ·ªü 25% t·ª´ tr√°i sang
                noteRadius: 10,       // B√°n k√≠nh n·ªët nh·∫°c (h√¨nh tr√≤n)
                hitZoneColor: 'rgba(0, 255, 255, 0.7)', // M√†u V·∫°ch G·∫£y (Cyan trong su·ªët)
                noteColor: 'rgba(255, 255, 255, 0.9)'  // M√†u N·ªët ƒê√≠ch (Tr·∫Øng g·∫ßn ƒë·ª•c)
            }
            // === H·∫æT PH·∫¶N M·ªöI ===
        };
        // === H·∫æT PH·∫¶N THAY TH·∫æ ===

        // ==== Variables for improved interaction ====
        let lastPluckTime = new Array(DAN_TRANH_CONFIG.numStrings).fill(0);
        const PLUCK_COOLDOWN_MS = 150;
        let prevHands = [];
        let lastFrameTime = performance.now();

        // === M·ªöI: DANH S√ÅCH FILE √ÇM THANH (T·ª∞ ƒê·ªòNG L·∫§Y ƒê∆Ø·ªúNG D·∫™N ƒê·∫¶Y ƒê·ª¶) ===

        // B·∫°n B·∫ÆT BU·ªòC ph·∫£i ƒëi·ªÅn ƒë√∫ng 17 ƒë∆∞·ªùng d·∫´n file .wav c·ªßa m√¨nh v√†o ƒë√¢y
        // 1. Khai b√°o m·∫£ng ch·ª©a T√äN file (ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi)
        const NOTE_NAMES = [
            'sounds/1_G.wav',  // D√¢y 1: G (tr·∫ßm)
            'sounds/1_A.wav',  // D√¢y 2: A
            'sounds/1_C.wav',  // D√¢y 3: C
            'sounds/1_D.wav',  // D√¢y 4: D
            'sounds/1_E.wav',  // D√¢y 5: E
            'sounds/2_G.wav',  // D√¢y 6: G
            'sounds/2_A.wav',  // D√¢y 7: A
            'sounds/2_C.wav',  // D√¢y 8: C
            'sounds/2_D.wav',  // D√¢y 9: D
            'sounds/2_E.wav',  // D√¢y 10: E
            'sounds/3_G.wav',  // D√¢y 11: G
            'sounds/3_A.wav',  // D√¢y 12: A
            'sounds/3_C.wav',  // D√¢y 13: C
            'sounds/3_D.wav',  // D√¢y 14: D
            'sounds/3_E.wav',  // D√¢y 15: E
            'sounds/4_G.wav',  // D√¢y 16: G
            'sounds/4_A.wav'   // D√¢y 17: A (cao nh·∫•t)
        ];

        // 2. D√πng m·∫£ng NOTE_NAMES ·ªü tr√™n ƒë·ªÉ t·∫°o ra m·∫£ng NOTE_FILES ch·ª©a ƒë∆∞·ªùng d·∫´n ƒê·∫¶Y ƒê·ª¶
        const NOTE_FILES = NOTE_NAMES.map(relativePath => {
            return new URL(relativePath, window.location.href).href;
        });

        console.log("Generated full audio paths:", NOTE_FILES); // B·∫°n c√≥ th·ªÉ ki·ªÉm tra trong Console (F12)

        // === H·∫æT PH·∫¶N M·ªöI ===

        // === ƒê√É S·ª¨A: Ch·ªâ 3 ng√≥n tay ===
        const DAN_TRANH_HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4], // Ng√≥n c√°i (Thumb)
            [0, 5], [5, 6], [6, 7], [7, 8], // Ng√≥n tr·ªè (Index)
            [0, 9], [9, 10], [10, 11], [11, 12], // Ng√≥n gi·ªØa (Middle)
            [5, 9] // N·ªëi l√≤ng b√†n tay (t·ª´ tr·ªè sang gi·ªØa)
        ];

        // === H√ÄM V·∫º ƒê√ÄN TRANH (ƒê√É S·ª¨A) ===
        // H√†m n√†y gi·ªù ƒë·ªçc t·ªça ƒë·ªô t·ª´ `danTranhStrings`
        function drawDanTranh(ctx, width, height) {
            // 1. V·∫Ω n·ªÅn G·ªó (thay cho video)
            if (showDanTranh) {
                ctx.fillStyle = DAN_TRANH_CONFIG.backgroundColor;
                ctx.fillRect(0, 0, width, height);
            } else {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, width, height);
                return; 
            }

            // N·∫øu m·∫£ng t·ªça ƒë·ªô ch∆∞a s·∫µn s√†ng th√¨ kh√¥ng v·∫Ω
            if (danTranhStrings.length === 0) return; 

            // 2. L·∫•y t·ªça ƒë·ªô t·ª´ m·∫£ng (thay v√¨ t√≠nh to√°n l·∫°i)
            const startX = danTranhStrings[0].startX;
            const endX = danTranhStrings[0].endX;
            const topY = danTranhStrings[0].y;
            const bottomY = danTranhStrings[danTranhStrings.length - 1].y;
            const bridgeWidth = DAN_TRANH_CONFIG.bridgeWidth;

            // 3. V·∫Ω khung ƒë√†n (thanh d·ªçc ·ªü 2 b√™n)
            const frameGradientLeft = ctx.createLinearGradient(startX - 20, topY, startX + 10, topY);
            frameGradientLeft.addColorStop(0, 'rgba(101, 67, 33, 0.8)');
            frameGradientLeft.addColorStop(1, 'rgba(139, 90, 43, 0.8)');
            ctx.fillStyle = frameGradientLeft;
            ctx.fillRect(startX - 20, topY - 10, 30, bottomY - topY + 20); // Khung tr√°i

            const frameGradientRight = ctx.createLinearGradient(endX - 10, topY, endX + 20, topY);
            frameGradientRight.addColorStop(0, 'rgba(139, 90, 43, 0.8)');
            frameGradientRight.addColorStop(1, 'rgba(101, 67, 33, 0.8)');
            ctx.fillStyle = frameGradientRight;
            ctx.fillRect(endX - 10, topY - 10, 30, bottomY - topY + 20); // Khung ph·∫£i

            // 4. V·∫Ω d√¢y ƒë√†n (n·∫±m ngang) - L·∫∑p qua m·∫£ng t·ªça ƒë·ªô
            danTranhStrings.forEach((string, i) => {
                const y = string.y;
                const stringWidth = string.endX - string.startX;
                
                // V·∫Ω con nh·∫°n (c·∫ßu di ƒë·ªông)
                const bridgeX = string.startX + (stringWidth * 0.7); 
                const bridgeGradient = ctx.createLinearGradient(bridgeX, y - 8, bridgeX, y + 8);
                bridgeGradient.addColorStop(0, 'rgba(160, 82, 45, 0.6)');
                bridgeGradient.addColorStop(0.5, 'rgba(205, 133, 63, 0.8)');
                bridgeGradient.addColorStop(1, 'rgba(160, 82, 45, 0.6)');
                
                ctx.fillStyle = bridgeGradient;
                ctx.beginPath();
                ctx.moveTo(bridgeX, y); // ƒê·ªânh
                ctx.lineTo(bridgeX + bridgeWidth, y - 8); // Ch√¢n ph·∫£i
                ctx.lineTo(bridgeX + bridgeWidth, y + 8); // Ch√¢n tr√°i
                ctx.closePath();
                ctx.fill();

                // V·∫Ω b√≥ng d√¢y ƒë√†n
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(string.startX, y + 2);
                ctx.lineTo(string.endX, y + 2);
                ctx.stroke();

                // V·∫Ω d√¢y ƒë√†n ch√≠nh v·ªõi gradient
                const stringGradient = ctx.createLinearGradient(string.startX, y, string.endX, y);
                stringGradient.addColorStop(0, DAN_TRANH_CONFIG.stringColors[i]);
                stringGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.4)');
                stringGradient.addColorStop(1, DAN_TRANH_CONFIG.stringColors[i]);
                
                ctx.strokeStyle = stringGradient;
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(string.startX, y);
                ctx.lineTo(string.endX, y);
                ctx.stroke();

                // Th√™m vi·ªÅn s√°ng cho d√¢y
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(string.startX, y - 1);
                ctx.lineTo(string.endX, y - 1);
                ctx.stroke();

                // V·∫Ω s·ªë th·ª© t·ª± d√¢y (b√™n tr√°i)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(i + 1, string.startX - 30, y + 5);
            });
        }
        // === H·∫æT H√ÄM V·∫º ===

        function drawRhythmElements(ctx, width, height) {
            if (danTranhStrings.length === 0) return;
            const config = DAN_TRANH_CONFIG.rhythmGame;
            const hitZoneX = width * config.hitZoneXPercent;

            // V·∫°ch G·∫£y th·∫≥ng ƒë·ª©ng b√™n ph·∫£i
            ctx.strokeStyle = config.hitZoneColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(hitZoneX, danTranhStrings[0].y - 20);
            ctx.lineTo(hitZoneX, danTranhStrings[danTranhStrings.length - 1].y + 20);
            ctx.stroke();

            // V·∫Ω n·ªët ƒë√≠ch tƒ©nh ·ªü ƒë·∫ßu d√¢y (b√™n ph·∫£i)
            danTranhStrings.forEach(string => {
                ctx.beginPath();
                ctx.arc(hitZoneX, string.y, config.noteRadius, 0, 2 * Math.PI);
                ctx.fillStyle = config.noteColor;
                ctx.fill();
            });
        }


        async function loadAudioFiles() {
            try {
                // Kh·ªüi t·∫°o AudioContext (s·∫Ω b·ªã suspended ƒë·∫øn khi user click)
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const loadPromises = NOTE_FILES.map(async (filePath) => {
                const response = await fetch(filePath);
                if (!response.ok) throw new Error("Kh√¥ng th·ªÉ t·∫£i " + filePath);
                const buffer = await response.arrayBuffer();
                return await audioContext.decodeAudioData(buffer);
                });
                audioBuffers = await Promise.all(loadPromises);
                console.log("ƒê√£ t·∫£i √¢m thanh th√†nh c√¥ng");
            } catch (err) {
                console.error(err);
                showError("L·ªói t·∫£i √¢m thanh: " + err.message);
            }
        }

        async function ensureAudioContextRunning() {
            if (!audioContext)
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext.state === "suspended") {
                try {
                await audioContext.resume();
                } catch (e) {
                console.warn("Kh√¥ng th·ªÉ resume AudioContext", e);
                }
            }
        }

        async function playNote(stringIndex) {
            if (stringIndex < 0 || stringIndex >= audioBuffers.length) return;
            await ensureAudioContextRunning();
            const buffer = audioBuffers[stringIndex];
            if (!buffer) return;
            const src = audioContext.createBufferSource();
            src.buffer = buffer;
            src.connect(audioContext.destination);
            src.start(0);
        }


        function showError(msg) {
            errorMessage.textContent = msg;
            errorOverlay.classList.add('show');
            loadingOverlay.classList.add('hidden');
            statusText.textContent = 'L·ªói';
            statusText.className = 'value status-loading';
        }
        
        // === H√ÄM X·ª¨ L√ù FALLING NOTES & SCORING ===
        // === N·ªêT CH·∫†Y NGANG (T·ª™ TR√ÅI ‚Üí PH·∫¢I) ===
        function drawFallingNotes(ctx, width, height) {
            if (!isPlayingSong) return;
            const elapsed = performance.now() - songStartTime;

            // T·ªëc ƒë·ªô ch·∫°y ngang (pixel m·ªói ms)
            const speedX = width * 0.00025;

            fallingNotes.forEach(note => {
                const targetString = danTranhStrings[note.string];
                if (!targetString) return;

                // v·ªã tr√≠ X d·ª±a theo th·ªùi gian
                const t = (elapsed - note.time);
                const x = (width * 0.1) + t * speedX; // b·∫Øt ƒë·∫ßu t·ª´ 10% b√™n tr√°i
                const y = targetString.y;

                // ch·ªâ v·∫Ω khi trong m√†n h√¨nh
                if (x > 0 && x < width) {
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.fill();

                    // Hi·ªáu ·ª©ng √°nh s√°ng
                    const glow = ctx.createRadialGradient(x, y, 0, x, y, 20);
                    glow.addColorStop(0, 'rgba(255,255,255,0.6)');
                    glow.addColorStop(1, 'rgba(255,255,255,0)');
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // lo·∫°i b·ªè n·ªët ƒë√£ ch·∫°y kh·ªèi m√†n
            fallingNotes = fallingNotes.filter(n => (elapsed - n.time) < 7000);
        }


        // Khi ng∆∞·ªùi ch∆°i g·∫£y d√¢y (ƒë∆∞·ª£c g·ªçi trong onResults)
        function handlePluck(stringIndex) {
            if (!isPlayingSong) return;
            const elapsed = performance.now() - songStartTime;

            const width = canvasElement.width;
            const speedX = width * 0.00025;
            const hitZoneX = width * DAN_TRANH_CONFIG.rhythmGame.hitZoneXPercent;

            let bestNote = null;
            let bestDiff = Infinity;

            for (const note of fallingNotes) {
                if (note.string === stringIndex) {
                const noteX = (width * 0.1) + (elapsed - note.time) * speedX;
                const diff = Math.abs(noteX - hitZoneX);
                if (diff < bestDiff) {
                    bestDiff = diff;
                    bestNote = note;
                }
                }
            }

            if (bestNote && bestDiff < 40) {
                score += Math.max(0, 100 - bestDiff * 2);
                combo++;
                maxCombo = Math.max(maxCombo, combo);
                accuracyList.push(bestDiff);
                fallingNotes = fallingNotes.filter(n => n !== bestNote);
            } else {
                combo = 0;
            }
        }


        // Kh·ªüi t·∫°o b√†i h√°t
        function startSong(songId) {
            if (!SONGS[songId]) return;
            currentSong = SONGS[songId];
            isPlayingSong = true;
            score = 0;
            combo = 0;
            maxCombo = 0;
            accuracyList = [];
            fallingNotes = JSON.parse(JSON.stringify(currentSong.notes));
            songStartTime = performance.now();

            // === THU G·ªåN C√íN 5 D√ÇY V√Ä PH√ìNG TO ===
            DAN_TRANH_CONFIG.numStrings = 5;

            // L·∫•y 5 d√¢y trung t√¢m (ho·∫∑c t·ª´ 6‚Äì10)
            const startIndex = 6; // d√¢y 7 ƒë·∫øn 11 
            danTranhStrings = danTranhStrings.slice(startIndex, startIndex + 5);

            // Ph√≥ng to v√πng hi·ªÉn th·ªã b·∫±ng c√°ch scale theo chi·ªÅu d·ªçc
            const height = staticCanvas.height;
            const zoomFactor = 1.5;
            const centerY = height / 2;
            danTranhStrings.forEach(s => {
                s.y = centerY + (s.y - centerY) * zoomFactor;
            });

            stringStates = new Array(5).fill(0);

            staticCtx.clearRect(0, 0, staticCanvas.width, staticCanvas.height);
            drawDanTranh(staticCtx, staticCanvas.width, staticCanvas.height);
            drawRhythmElements(staticCtx, staticCanvas.width, staticCanvas.height);

            // === C·∫¨P NH·∫¨T L·∫†I ID, √ÇM THANH, V√Ä TR·∫†NG TH√ÅI D√ÇY ===

            // G√°n l·∫°i id cho 5 d√¢y m·ªõi (0‚Äì4)
            danTranhStrings.forEach((s, i) => s.id = i);

            // C·∫≠p nh·∫≠t l·∫°i m·∫£ng tr·∫°ng th√°i & hi·ªáu ·ª©ng rung
            stringStates = new Array(danTranhStrings.length).fill(0);

            // C·∫≠p nh·∫≠t l·∫°i m·∫£ng √¢m thanh: ch·ªâ gi·ªØ 5 file ƒë·∫ßu (ho·∫∑c map ƒë√∫ng n·ªët Tr·ªëng C∆°m)
            noteAudios = noteAudios.slice(0, 5);

            // N·∫øu b·∫°n d√πng file .wav ri√™ng t·ª´ng d√¢y th√¨ n√™n ki·ªÉm tra l·∫°i th·ª© t·ª±:
            NOTE_FILES = [
            "sounds/1_G.wav",
            "sounds/1_A.wav",
            "sounds/1_C.wav",
            "sounds/1_D.wav",
            "sounds/1_E.wav"
            ];
            loadAudioFiles(NOTE_FILES);

        }


        function stopSong() {
            isPlayingSong = false;
            DAN_TRANH_CONFIG.numStrings = 17;
            initializeApp(); // kh·ªüi ƒë·ªông l·∫°i ƒë√†n ƒë·∫ßy ƒë·ªß
        }

        // === H√ÄM ONRESULTS (ƒê√É S·ª¨A HO√ÄN CH·ªàNH) ===
        function onResults(results) {
            // 1. X√≥a canvas
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // 2. V·∫Ω n·ªÅn ƒë√†n tranh (copy t·ª´ canvas ·∫©n)
            if (showDanTranh) {
                canvasCtx.drawImage(staticCanvas, 0, 0);
            }

            // 3. C·∫≠p nh·∫≠t s·ªë tay
            const handCount = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
            handCountEl.textContent = handCount;

            // 4. V·∫Ω tay (n·∫øu b·∫≠t)
            if (showHands && results.multiHandLandmarks) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handedness = results.multiHandedness[i];

                    drawConnections(canvasCtx, landmarks);
                    drawLandmarks(canvasCtx, landmarks);

                    const wrist = landmarks[0];
                    const x = wrist.x * canvasElement.width;
                    const y = wrist.y * canvasElement.height;

                    canvasCtx.fillStyle = '#00ff00';
                    canvasCtx.font = 'bold 24px Arial';
                }
            }

            // === PATCH 6: LOGIC G·∫¢Y D√ÇY M∆Ø·ª¢T V√Ä CH√çNH X√ÅC H∆†N ===
            const now = performance.now();
            const dt = Math.max(1, now - lastFrameTime);
            lastFrameTime = now;

            const pluckToleranceY = 15;            // v√πng ch·∫°m
            const velocityThreshold = 0.05;        // v·∫≠n t·ªëc t·ªëi thi·ªÉu
            const accelThreshold = 0.02;           // gia t·ªëc t·ªëi thi·ªÉu
            const crossingMinDelta = 3;           // v∆∞·ª£t d√¢y √≠t nh·∫•t 10px
            const currentlyTouching = new Array(DAN_TRANH_CONFIG.numStrings).fill(false);

            const currentHands = [];
            if (results.multiHandLandmarks) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const label = results.multiHandedness[i]?.label || ('hand' + i);
                    currentHands.push({ label, landmarks: results.multiHandLandmarks[i] });
                }
            }

            for (const hand of currentHands) {
                const prev = prevHands.find(h => h.label === hand.label);
                for (const idx of FINGER_TIP_LANDMARKS) {
                    const cur = hand.landmarks[idx];
                    const prevTip = prev ? prev.landmarks[idx] : null;
                    if (!cur) continue;

                    const curX = (1 - cur.x) * canvasElement.width;
                    const curY = cur.y * canvasElement.height;
                    const prevY = prevTip ? prevTip.y * canvasElement.height : curY;
                    const velY = (curY - prevY) / dt;

                    // === NEW: T√≠nh gia t·ªëc (acceleration) ===
                    const prevVelY = prevTip ? (prevTip._velY || 0) : 0;
                    const accelY = velY - prevVelY;
                    if (cur) cur._velY = velY; // l∆∞u l·∫°i ƒë·ªÉ frame sau d√πng

                    for (const string of danTranhStrings) {
                        const overX = curX > string.startX && curX < string.endX;
                        const near = Math.abs(curY - string.y) < pluckToleranceY;

                        // === NEW: ki·ªÉm tra crossing th·∫≠t s·ª± c√≥ bi√™n ƒë·ªô ƒë·ªß l·ªõn ===
                        const crossed = (
                            (prevY < string.y && curY - string.y > crossingMinDelta) ||
                            (prevY > string.y && string.y - curY > crossingMinDelta)
                        );

                        if (overX && near) currentlyTouching[string.id] = true;

                        // === NEW: G·∫£y th·∫≠t s·ª± (ƒë·∫ßy ƒë·ªß ƒëi·ªÅu ki·ªán) ===
                        if (
                            overX &&
                            crossed &&
                            Math.abs(velY) > velocityThreshold &&
                            Math.abs(accelY) > accelThreshold &&
                            stringStates[string.id] === 0
                        ) {
                            const nowMs = performance.now();
                            if (nowMs - lastPluckTime[string.id] >= PLUCK_COOLDOWN_MS) {
                                lastPluckTime[string.id] = nowMs;
                                stringStates[string.id] = 10;
                                playNote(string.id);
                                handlePluck(string.id);
                                console.log(`G·∫£y d√¢y ${string.id + 1} (ng√≥n ${idx}, vel=${velY.toFixed(3)}, acc=${accelY.toFixed(3)})`);
                                break;
                            }
                        }
                    }
                }
            }

            // C·∫≠p nh·∫≠t prevHands
            prevHands = currentHands.map(h => ({
                label: h.label,
                landmarks: JSON.parse(JSON.stringify(h.landmarks))
            }));



            // 6. HI·ªÜU ·ª®NG RUNG D√ÇY M∆Ø·ª¢T
            for (let i = 0; i < DAN_TRANH_CONFIG.numStrings; i++) {
                const string = danTranhStrings[i];
                if (stringStates[i] > 0) stringStates[i]--;

                const amp = Math.sin(now / 30) * stringStates[i] * 0.4;
                const gradient = canvasCtx.createLinearGradient(string.startX, string.y, string.endX, string.y);
                gradient.addColorStop(0, "#ffb347");
                gradient.addColorStop(1, "#ffd700");
                canvasCtx.strokeStyle = gradient;
                canvasCtx.lineWidth = 2;
                canvasCtx.beginPath();
                const wave = Math.sin(now / 25) * 0.2;
                const midY = string.y + amp * Math.sin((i * 0.5 + now / 120) % Math.PI);
                canvasCtx.moveTo(string.startX, midY - wave);
                canvasCtx.lineTo(string.endX, midY + wave);
                canvasCtx.stroke();
            }

            // 7. T√çNH FPS
            frameCount++;
            const nowTime = Date.now();
            if (nowTime - lastTime >= 1000) {
                currentFps = frameCount;
                fpsCountEl.textContent = currentFps;
                frameCount = 0;
                lastTime = nowTime;
            }

            // 8. L∆∞u l·∫°i tr·∫°ng th√°i frame n√†y
            previousTouching = [...currentlyTouching];
            previousHandLandmarks = results.multiHandLandmarks ? JSON.parse(JSON.stringify(results.multiHandLandmarks)) : [];
            
            // === C·∫¨P NH·∫¨T HUD ===
            document.getElementById("scoreText").textContent = Math.round(score);
            document.getElementById("comboText").textContent = combo;

            // V·∫Ω n·ªët r∆°i (n·∫øu ƒëang ch∆°i)
            drawFallingNotes(canvasCtx, canvasElement.width, canvasElement.height);

        }
        // === H·∫æT H√ÄM ONRESULTS ===


        // === H√ÄM V·∫º ƒê∆Ø·ªúNG N·ªêI CHU·∫®N 5 NG√ìN (THEO MEDIA PIPE) ===
        function drawConnections(ctx, landmarks) {
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
            ctx.lineWidth = 2;

            const fingers = [
                [0, 1, 2, 3, 4],    // Thumb
                [0, 5, 6, 7, 8],    // Index
                [0, 9, 10, 11, 12], // Middle
                [0, 13, 14, 15, 16],// Ring
                [0, 17, 18, 19, 20] // Pinky
            ];

            ctx.beginPath();
            for (const finger of fingers) {
                for (let i = 0; i < finger.length - 1; i++) {
                const a = landmarks[finger[i]];
                const b = landmarks[finger[i + 1]];
                ctx.moveTo(a.x * canvasElement.width, a.y * canvasElement.height);
                ctx.lineTo(b.x * canvasElement.width, b.y * canvasElement.height);
                }
            }
            ctx.stroke();
        }


        // === H√ÄM V·∫º ƒêI·ªÇM (ƒê√É S·ª¨A) ===
        // === PHI√äN B·∫¢N M√ÄU 5 NG√ìN (N·∫æU MU·ªêN PH√ÇN BI·ªÜT) ===
        function drawLandmarks(ctx, landmarks) {
            const fingerColors = ['#ff4444', '#44ff44', '#4444ff', '#ffbb33', '#aa44ff'];
            const fingers = [
                [0, 1, 2, 3, 4], [5, 6, 7, 8],
                [9, 10, 11, 12], [13, 14, 15, 16],
                [17, 18, 19, 20]
            ];

            for (let f = 0; f < fingers.length; f++) {
                ctx.beginPath();
                for (const i of fingers[f]) {
                const lm = landmarks[i];
                const x = lm.x * canvasElement.width;
                const y = lm.y * canvasElement.height;
                ctx.moveTo(x, y);
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                }
                ctx.fillStyle = fingerColors[f];
                ctx.fill();
            }
        }



        // === H·∫æT H√ÄM V·∫º ƒêI·ªÇM ===

        async function getCameraList() {
            try {
                const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
                tempStream.getTracks().forEach(track => track.stop());

                const devices = await navigator.mediaDevices.enumerateDevices();
                availableCameras = devices.filter(device => device.kind === 'videoinput');
                
                cameraSelect.innerHTML = '';
                
                if (availableCameras.length === 0) {
                    cameraSelect.innerHTML = '<option value="">Kh√¥ng t√¨m th·∫•y camera</option>';
                    return;
                }

                availableCameras.forEach((camera, index) => {
                    const option = document.createElement('option');
                    option.value = camera.deviceId;
                    option.textContent = camera.label || `Camera ${index + 1}`;
                    cameraSelect.appendChild(option);
                });

                switchCameraBtn.disabled = false;
            } catch (err) {
                console.error('Error getting camera list:', err);
                cameraSelect.innerHTML = '<option value="">L·ªói khi t·∫£i camera</option>';
                showError('Kh√¥ng th·ªÉ l·∫•y danh s√°ch camera. Vui l√≤ng c·∫•p quy·ªÅn truy c·∫≠p camera v√† t·∫£i l·∫°i trang.');
            }
        }

        async function stopCurrentCamera() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
            if (cameraInstance) {
                cameraInstance.stop();
                cameraInstance = null;
            }
            videoElement.srcObject = null;
        }

        // === H√ÄM STARTCAMERA (ƒê√É T·ªêI ∆ØU - D√ôNG CAMERA C·ª¶A MEDIAPIPE) ===
        async function startCamera(deviceId) {
        if (isSwitching) return;

        try {
            isSwitching = true;
            switchCameraBtn.disabled = true;
            switchCameraBtn.textContent = 'ƒêang ƒë·ªïi...';
            loadingOverlay.classList.remove('hidden');
            errorOverlay.classList.remove('show');

            await stopCurrentCamera();
            await new Promise((resolve) => setTimeout(resolve, 500));

            const constraints = {
            video: {
                width: 1280,
                height: 720,
                deviceId: deviceId ? { exact: deviceId } : undefined,
            },
            };
            currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            videoElement.srcObject = currentStream;

            await new Promise((resolve) => (videoElement.onloadedmetadata = resolve));
            await videoElement.play();

            const width = videoElement.videoWidth;
            const height = videoElement.videoHeight;
            canvasElement.width = width;
            canvasElement.height = height;

            // === T√çNH TO√ÅN D√ÇY ƒê√ÄN ===
            staticCanvas.width = width;
            staticCanvas.height = height;
            danTranhStrings = [];
            stringStates.fill(0);

            const { startX, endX, topY, bottomY, numStrings } = DAN_TRANH_CONFIG;
            const stringSpacing = (height * bottomY - height * topY) / (numStrings - 1);
            for (let i = 0; i < numStrings; i++) {
            const y = height * topY + i * stringSpacing;
            danTranhStrings.push({
                id: i,
                y,
                startX: width * startX,
                endX: width * endX,
            });
            }

            drawDanTranh(staticCtx, width, height);
            drawRhythmElements(staticCtx, width, height);

            // === D√ôNG CAMERA C·ª¶A MEDIAPIPE (R·∫§T M∆Ø·ª¢T) ===
            cameraInstance = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720,
            });
            cameraInstance.start();

            loadingOverlay.classList.add('hidden');
            statusText.textContent = 'ƒêang ph√°t hi·ªán';
            statusText.className = 'value status-detecting';

            currentCamera = deviceId;
            cameraSelect.value = deviceId;
            switchCameraBtn.disabled = false;
            switchCameraBtn.textContent = 'ƒê·ªïi Camera';
            isSwitching = false;
        } catch (err) {
            isSwitching = false;
            switchCameraBtn.disabled = false;
            switchCameraBtn.textContent = 'ƒê·ªïi Camera';
            showError('Kh√¥ng th·ªÉ truy c·∫≠p camera: ' + err.message);
        }
        }


        async function initializeApp() {
            try {
                hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });

                hands.setOptions({
                    selfieMode: true,
                    maxNumHands: 2,
                    modelComplexity: 0,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults(onResults);

                // === TH√äM D√íNG N√ÄY V√ÄO ===
                await loadAudioFiles(); // T·∫£i √¢m thanh tr∆∞·ªõc khi l√†m m·ªçi th·ª©
                // === H·∫æT PH·∫¶N TH√äM ===

                await getCameraList();
                
                const defaultCamera = availableCameras.length > 0 ? availableCameras[0].deviceId : null;
                if (defaultCamera) {
                    cameraSelect.value = defaultCamera;
                    await startCamera(defaultCamera);
                } else if (availableCameras.length === 0 && !errorOverlay.classList.contains('show')) {
                    showError('Kh√¥ng t√¨m th·∫•y camera n√†o tr√™n thi·∫øt b·ªã');
                }

            } catch (err) {
                showError('L·ªói kh·ªüi t·∫°o: ' + err.message);
            }
        }

        switchCameraBtn.addEventListener('click', async () => {
           const selectedCamera = cameraSelect.value;
           if (selectedCamera && selectedCamera !== currentCamera && !isSwitching) {
               await startCamera(selectedCamera);
           }
        });

        showDanTranhToggle.addEventListener('change', (e) => {
            showDanTranh = e.target.checked;
            
            // V·∫Ω l·∫°i canvas ƒë·ªám khi b·∫≠t/t·∫Øt
            staticCtx.clearRect(0, 0, staticCanvas.width, staticCanvas.height);
            // (H√†m startCamera s·∫Ω t√≠nh l·∫°i danTranhStrings n·∫øu c·∫ßn)
            // T·ªët h∆°n l√† g·ªçi l·∫°i h√†m t√≠nh to√°n v√† v·∫Ω
            
            // T√≠nh to√°n l·∫°i t·ªça ƒë·ªô v√† v·∫Ω l·∫°i (an to√†n nh·∫•t)
            const { startX, endX, topY, bottomY, numStrings } = DAN_TRANH_CONFIG;
            const stringSpacing = (staticCanvas.height * bottomY - staticCanvas.height * topY) / (numStrings - 1);
            
            danTranhStrings = []; // X√≥a c≈©
            for (let i = 0; i < numStrings; i++) {
                const y = staticCanvas.height * topY + i * stringSpacing;
                danTranhStrings.push({
                    id: i,
                    y: y,
                    startX: staticCanvas.width * startX,
                    endX: staticCanvas.width * endX
                });
            }
            drawDanTranh(staticCtx, staticCanvas.width, staticCanvas.height);

            drawRhythmElements(staticCtx, staticCanvas.width, staticCanvas.height);
        });

        showHandsToggle.addEventListener('change', (e) => {
            showHands = e.target.checked;
        });
        // === G·∫ÆN S·ª∞ KI·ªÜN CH∆†I NH·∫†C ===
        const songSelect = document.getElementById('songSelect');
        const startSongBtn = document.getElementById('startSongBtn');
        const stopSongBtn = document.getElementById('stopSongBtn');

        startSongBtn.addEventListener('click', () => {
            const songId = songSelect.value;
            if (!songId) {
                alert("Vui l√≤ng ch·ªçn b√†i h√°t!");
                return;
            }
            startSong(songId);
            startSongBtn.disabled = true;
            stopSongBtn.disabled = false;
        });

        stopSongBtn.addEventListener('click', () => {
            stopSong();
            startSongBtn.disabled = false;
            stopSongBtn.disabled = true;
        });

        window.addEventListener('load', initializeApp);

        window.addEventListener('beforeunload', () => {
            stopCurrentCamera();
        });
    </script>
</body>
</html>